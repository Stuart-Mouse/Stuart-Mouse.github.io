<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="manifest" href="manifest.json" />
    <link
          rel="icon"
          href="icon.png"
          type="image/png"
          sizes="512x512"
    />
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0">
    
    <script language="javascript" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/6.65.7/codemirror.min.css"></link>
    
    <style>
        :root {
            background-color: rgba(15%, 8%, 8%, 1);
        }
        
        body {
            container-name: root;
            container-type: size;
            padding: 0;
            margin: 0;
            width:  100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #tray {
            --header-max-height: 2em;
            
            width: 100vw;
            
            z-index: 3;
            position: absolute;
            bottom: 0;
            
            margin: 0px;
            padding: 10px;
            
            background-color: #000000dd;
            box-sizing: border-box;
        }
        
        #tray-header {
            height: fit-content;
            max-height: var(--header-max-height);
            width:  100%;
            
            max-width:  100%;
            overflow-x: auto;
        	scrollbar-width: thin;
        	scrollbar-color: #ffffff #00000000;
            white-space: nowrap;
        }
        
        #tray-body {
            box-sizing: border-box;
            overflow: hidden;
            
            padding: 0;
            margin: 0;
            margin-top: 10px;
        }
        
        #show-tray {
            background-color: #33333388;
            border-color: #33333388;
            color: white;
        }
        
        #show-tray-label {
            color: white;
        }
        
        #script-error {
            color: white;
            white-space: nowrap;
        }
        
        #compile-button {
            color: white;
            background-color: #33333388;
            border-color: #33333388;
        }
        
        #Mooviz {
            width:  min(100vw, 100vh);
            height: min(100vw, 100vh);
        }
        
        @container root ((width < 60em) or (aspect-ratio < 16/10)) {
            #tray {
                bottom: 0px;
            }
            
            #Mooviz {
                width:  100vw;
            }
            
            #tray-body {
                margin-top: 0;
                max-height: 0;
                transition: all .3s ease-in-out;
            }
            
            #tray-header:has(#show-tray:checked) ~ #tray-body {
                margin-top: 10px;
                max-height: max(calc(100vh - min(100vw, 100vh)), 300px);
                height:     max(calc(100vh - min(100vw, 100vh)), 300px);
            }
        }
        
        @container root (not ((width < 60em) or (aspect-ratio < 16/10))) {
            #tray {
                top: 0px;
                right: 0px;
                
                height: 100vh;
                max-height: 100vh;
                width: calc(100vw - min(100vw, 100vh));
            }
            
            #tray-body {
                height: calc(100% - var(--header-max-height));
            }
            
            #show-tray, #show-tray-label {
                display: none;
            }
        }
        
        /* CodeMirror Style Overrides */
        
        .CodeMirror {
            background-color: #33333388;
            border-radius: 5px;
            // height: calc(100% - 3em);
            height: 100%;
        }
        
        .CodeMirror-scroll ::-moz-selection { /* Code for Firefox */
            color:      rgba(0,0,0,1);
            background: rgba(0,0,0,1);
        }
        
        .CodeMirror-scroll ::selection {
            color:      rgba(0,0,0,1);
            background: rgba(0,0,0,1);
        }
        
        .CodeMirror-gutters {
            background-color: #333333;
        }
        
        .CodeMirror-scroll {
            color: white;
        }
        
        .CodeMirror-scroll, .CodeMirror-vscrollbar, .CodeMirror-hscrollbar {
        	scrollbar-width: thin;
        	scrollbar-color: #ffffff #333333;
        }
        
        .CodeMirror-cursor {
            border-left: 1px solid #fff;
        }
        
        .CodeMirror-selected {
            background-color: #000000ff;
        }
    </style>
</head>

<body>
    <div id="tray">
        <div id="tray-header">
            <button type="button" id="compile-button" onclick="
                document.getElementById('script-error').innerHTML = '';
                jai_exports.compile_script(); 
            ">Compile</button>
            <label for="compile-button" id="script-error"></label>
            <input type="checkbox" name="show-tray" id="show-tray"/>
            <label for="show-tray" id="show-tray-label">Show Source Code</label>
        </div>
        <div id="tray-body">
            <textarea id="script-source" spellcheck="false" name="script-source">placeholder text</textarea>
        </div>
    </div>
    <script>
    var editor = CodeMirror.fromTextArea(document.getElementById('script-source'), {
        lineNumbers: true,
        mode: 'text/python',
        matchBrackets: true,
    });
    </script>
    
    <script src="runtime.js"></script>
    
<!-- NOTE: it is good to see here that we can just redefine most of the stuff we would want to override from the standard runtime.js and put any extra functions we need here.
           so for future wasm projects we can just create a separate project_name.js file and not need to worry about runtime.js getting replaced each compile.
           On the other hand, we still do need to figure out how to prevent it overriding the index.html file, so probably only creating/copying that if the file does not already exist in the compilation destination folder -->
    <script>

const canvas_resize_listener = (window_id) => () => {
    const canvas  = get_canvas(window_id);
    const scale   = Math.ceil(window.devicePixelRatio);
    // canvas.width  = window.innerWidth  * scale;
    // canvas.height = window.innerHeight * scale;
    // canvas.style.width  = `${window.innerWidth}px`;
    // canvas.style.height = `${window.innerHeight}px`;
    canvas.getContext("2d").setTransform(scale, 0, 0, scale, 0, 0);
    // console.log("pixel ratio is ", scale);
    console.log("width:  ", canvas.width);
    console.log("height: ", canvas.height);
    console.log("client width:  ", canvas.clientWidth  * scale);
    console.log("client height: ", canvas.clientHeight * scale);
    
    canvas.width  = canvas.clientWidth  * scale;
    canvas.height = canvas.clientHeight * scale;
    
    staged_events.push([
        jai_exports.add_window_resize,
        window_id,
        canvas.clientWidth  * scale,
        canvas.clientHeight * scale,
    ])
};

jai_imports.js_set_script_error_message = (s_count, s_data, to_standard_error) => {
    const js_string = copy_string_to_js(s_count, s_data, false);
    let script_error = document.getElementById("script-error");
    script_error.innerHTML = js_string;
};

jai_imports.js_set_script_source_text = (s_count, s_data, to_standard_error) => {
    const js_string = copy_string_to_js(s_count, s_data, false);
    // let script_source = document.getElementById("script-source");
    // script_source.value = js_string;
    editor.setValue(js_string);
};

jai_imports.js_get_script_source_text = (out_pointer) => {
    // let script_source = document.getElementById("script-source");
    let script_source = editor.getValue();
    copy_string_from_js(out_pointer, script_source);
};

jai_imports.js_create_window = (width, height, name_count, name_data, name_is_constant, window_x, window_y, parent, bg_color_ptr, wanted_msaa) => {
    const name = copy_string_to_js(name_count, name_data, name_is_constant);
    const view = new DataView(jai_exports.memory.buffer);
    
    const offset  = Number(bg_color_ptr);
    const color_r = view.getFloat32(offset + 0, true);
    const color_g = view.getFloat32(offset + 4, true);
    const color_b = view.getFloat32(offset + 8, true);
    
    const window_id = BigInt(canvases.length);
    
    let canvas = document.getElementById(name);   
    if (canvas == null) {
        canvas        = document.createElement('canvas');
        canvas.id     = name;
        canvas.width  = Math.floor(0.5 + Number(width));
        canvas.height = Math.floor(0.5 + Number(height));
        canvas.style.backgroundColor = `rgba(${color_r * 255}, ${color_g * 255}, ${color_b * 255}, 1)`;
        canvas.style.position = "absolute";
        canvas.style.margin   = "0";
        
        // TODO: why is zero the default dimension here? shouldn't we just make it 100% as it was below?
        canvas.style.left     = `${(window_x === -1n) ? 0 : window_x}px`;
        canvas.style.top      = `${(window_y === -1n) ? 0 : window_y}px`;
        
        document.body.appendChild(canvas);
    } else {
        if (canvas.nodeName != "CANVAS") throw `Element with id ${name} is not a canvas`;
    }
    
    if (parent !== -1n) throw new Error("TODO: What does that even mean in this context?");
    
    canvases.push(canvas);
    
    // TODO: consider how we actually want to set up resizes on windows.
    //       if there is some existing canvas, for the window, then we should use that one, invariably I think.
    //          (if someone would prefer to resize/reposition that exisitng canvas to the provided window position/size then they ycan override this entire function pretty easily)
    //       but for my own uses, I would prefer to manage and resize the windows on the JS side and just have Jai respect it
    //          (as the outer context, the js/html side should have control over how the content is rendered, unless we are doing the totally blank page thing
    //           but I assume most jai wasm apps with nontrivial integration between js/jai will want some level of coexistence)
    //       also, why are we only setting a resize listener when the position of the window is unspecified?
    if (window_x === -1n && window_y === -1n) {
        if (canvas_resize_listener !== undefined) {
            const listen = canvas_resize_listener(window_id);
            window.addEventListener("resize", listen);
            listen();
        } else {
            const scale   = Math.ceil(window.devicePixelRatio);
            canvas.width  = window.innerWidth  * scale;
            canvas.height = window.innerHeight * scale;
        }
    }
    
    return window_id;
};

    </script>
</body>

</html>
