

<!DOCTYPE html>
<html>
    <head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>My Projects</title>
		<meta name="description" content="">
		<meta name="keywords"    content="">
		<meta name="author"      content="Stuart Mouse">
		<meta name="viewport"    content="width=device-width, initial-scale=1.0">
		<link rel="shortcut icon" type="image/x-icon" href="images/randomizer/icon.ico">
		<link rel="stylesheet" type="text/css" href="/style.css">
	</head>
    <body>
        

<canvas id="canvas" class="bg-wasm-canvas hide" oncontextmenu="event.preventDefault()"></canvas>
<!-- TODO: could figure out some way to `defer part of the output html for things like scripts that need to be run at end of block, or which should only be included once. -->
<!-- On a similar note, we should figure out a better way to scope certain scripts so that they don't refer to things outside the template unintentionally. -->
<script type="text/javascript">
    var Module = {};
    Module.canvas = document.getElementById('canvas');
</script>
<script async type="text/javascript" src="/bg_wasm.js"></script>
        <div class="content">
            
<div class="header">
  <input class="menu-btn" type="checkbox" id="menu-btn" />
  <label class="menu-icon" for="menu-btn"><span class="navicon"></span></label>
  <ul class="menu">
    
      <li><a href="/index.html">Home</a></li>
    
      <li><a href="/gon-parsers.html">GON Parsers</a></li>
    
      <li><a href="/game-dev.html">Game Dev</a></li>
    
      <li><a href="/blog/blog.html">Blog Posts</a></li>
    
  </ul>
</div><p>While I'm certainly not the most qualified person to write about this topic, perhaps my layman's perspective could be useful to a beginner who's never tried to write such a program before.</p>
<p>I am definitely not here to tell you how to implement a parser, but still being relatively close</p>
<p>Sometimes I feel that with enoug experiance doing something, one tends to forget many of the sneaky little things that tripped them up the first few go-arounds, as those things have just become implicit knowledge.</p>
<p>So, I'll take you on a little journey through my experience writing a GON parser in several different languages.</p>
<h2>straightforward port to C#</h2>
<p>The original GON implementation was done by Tyler Glaiel in C++.</p>
<p>Porting this implementation to C# was extremely straightforward, since</p>
<h2>C implementation</h2>
<p>This was one of my first real projects in C, as I was just moving away from C#.</p>
<p>This time, I took some pointers from rapidxml, particularly the idea of parsing 'in-situ'.</p>
<p>'In-situ' parsing basically just means that we don't copy strings form the source file as we create the DOM, rather we just reference the underlying file.
Now in retrospect it's a bit silly that this term even exists, because in a sensible language there's no reason you would naturally think to copy all of these substrings form the source file by default.
One would just use a a string view (or pointer + length), which references the underlying file in a completely non-destructive manner.
But in the C/C++ world we have two competing bad designs that all but force a beginner to do this the slow way in a naive implementation.
In C, strings are null-terminated, so using the source file directly means that we need to destructively modify it by inserting null characters at the end of the tokens we want to reference.
Depending on the syntax of the file format you're parsing, this may be very problematic, but in the case of XML or GON it is fine to do so.
And assuming that for some reason you don't want to or can't modify the underlying source file, your only option is to copy every single token you want to keep.
In C++, the std::string has its own ownership semantics which means that it may make any allocations it wants outside of the user's control.
In this case, a std::string will always make a copy when we intialize it with a substring from the source file.</p>
<p>So, short of implementing my own string view (and relevant functions) I decided to just go with the destructive null-insertion method.</p>
<p>For this implementation, I didn't really have any separation between the lexing and parsing of the file.
For a file format as simple as GON, there's really not much need to cleanly separate things in this way, but its worth noting.</p>
<p>With formats like JSON and XML, I think people sometimes ignore the fact that a parser is really just more of a lexer anyhow.
Even after the file has been parsed into a DOM representation, it still lacks any semantic meaning, and the program will then need to walk over the DOM and extract the information it needs, which is essentially just another phase of parsing.
Even if your JSON parser is really fast, using SIMD to churn through however many gigabytes of JSON per second, you're still going to need some slow, linear, user-level code to actually interpret the meaning of the DOM and validate its contents.</p>
<p>Although, if I were to go back and improve this implementation, I would probably go ahead and separate out the lexer a bit more so that I could improve the error messages and support utf8 instead of just ascii text.</p>
<h3>A shelved idea</h3>
<p>I really wanted to embed some kind of type information in the gon files so that I could automate the process of naviagting the</p>
<h2>SAX-style implementation in Jai</h2>
<p>For my first real program in Jai, I decided I wanted to port and improve my GON parser from C.
Having already known about Jai's type info system, I anticipated that I could use it to implement the reflection-based parsing that I could not do in C.
At first I began by doing a very strightforward port of the C code, though I quickly changed plans.
This time, I put in a proper separation between the lexing and parsing, basically just factoring out the lexing into a get_next_token() that the parser would call.</p>
<p>Around this time, I had also heard of the idea of a SAX-style parser (probably thanks to tsoding), and that seemed ideal to me, since it would allow me to maintain the single-pass architecture from the C implementation.</p>
<p>The user could create 'data bindings' to fields in the file simply by passing a path string and an <code>Any</code> which is just a pointer to some value and a pointer to the type info for that value.
Once the path matched to some field in the file, the data binding would have its value set directly from the string value in the file.</p>
<p>One part of this that I never really liked was the way I was comparing paths as I traversed the file.
It was this sort of weird system where I would pre-split the path into a <code>[] string</code>
Though I'm still not sure how else I would have done it in retrospect.</p>
<p>Other than the path substrings (which were done up-front), there were absolutely no additional allocations that the parser had to make.</p>
<p>Overall, the simplicity of this approach was quite nice.
But ultimately there are a few things that a sax-style parser cannot do that I wanted to be able to handle.</p>
<p>While I have not actually had the time to test this out, my hunch is that parsing into a very lean DOM and then evaluating data bindings on the dom may be a bit faster than parsing in the SAX mode.
The extra cost of allocating space for the nodes can be almost completely mitigated by just using an arena or pool allocator, and being able to navigate directly to a node when evaluating a data binding means we don't need to be constantly checking the paths of all the data bindings that are on a particular branch.
(I would really like to do the comparision some time after I clean up both implementations, but alas I have more important things to work on.)
Not to mention, it's much easier to extend the parser if it operates on a DOM, since the user code has much more context about where it is in the file.
And in a SAX-style parser, the only real method of extending the parser is through user callbacks, which may then need to influence control flow or report their own errors.</p>
<h2>Porting my Sax-style parser to Odin</h2>
<p>Since Odin is all the rage amongst Jai users who can't use Jai for thier more public projects yet, I decided to give it a try about a year ago, and of course I needed to port favorite parser yet again.
I don't have a ton to say about the</p>
<h2>Going back to DOM-style parsing</h2>
<p>My main reason for doing this ended up being the need to define references between fields in a file.
For example, I was using gon to define the tile types for a Mario clone, and I wanted to be able to specify the tiles
But of course, the parser is designed to translate directly from source text to the final, typed values (and without any intermediate representation).
So the only way to do this woul dbe to place a callback in the parser that runs for every single node, checking if it is a certain member of a certain struct and then interpreting the value accordingly, searching back through the array of previously loaded tiles to find the index of the one named in the file.
But wait, what if we want to reference a tile that is defined later in the file? Well we really just can't do that without needing to store some additional external infomration that lets us resolve the reference later</p>
<p>Anyways, I don't want to belabor the point any further, but as you can see none of the options are ideal.</p>
<p>This time I basically did both the Jai and Odin implementations at more or less that same time.
As I fixed things in one version or added new features I would port that fix/functionality to the other version.</p>
<p>In doing so I've just solidified my preference for Jai's type info system over Odin's.
Don't get me wrong, Odin's type info system is still very powerful, but it's just not quite as easy to work with and it lacks a few specific features that make implementing certain things much more hacky.
(
In particular, Odin's type info does not store any information about the abstract base type of a polymorphic struct.
So if we have for example, the following polymorphic struct:
<code>Fixed_String :: struct(N: int) { count:  int, data:   [N]u8, }</code>
```
And we want to dynamically identify an instance of this struct using a typeid, our only option is to parse the name to see if it starts with 'Fixed_String'.</p>
<pre><code>Whereas in Jai, there's an additional member in the Type_Info_Struct that points to the polymorph_source_struct.
</code></pre>
<p>)</p>
<h3>Implementing field references</h3>
<p>While it would already be much easier to implement some means for evaluating references between nodes on a DOM than it woul dbe in the SAX parser, I felt like this was a common enough use case that I wanted to support these field references in the very syntax of the gon file rather than requiring user callbacks</p>
<p>There are 3 types of field references that I wanted to implement:
index references, pointer references, and value references</p>
<p>index and pointer references were very straightforward
for index refs, we just grab the index of the specified node within its parent</p>
<p>for pointer refs, theres just a bit more checking to do, since we must make sure that there's a data binding to the field (otherwise what would we take the address of?)</p>
<p>but value references are where things get a bit more complicated
if the reference points to a simple field, we can just copy the string value of the field and replace the value ref node with a string node
But, if the reference points to a GON object or array, we need to copy that entire subtree of the DOM and paste those nodes in place of the reference
(We can't just point the reference at the existing subtree, since data bindings are stored on the nodes and we don't want to overwrite those.)
And best of all, what happens when we have a reference that points to another reference?
well now we have the potential for dependency chains to form and circular references to rear their ugly heads</p>
<p>My original plan was to just jump through references and first evaluate their dependencies, keeping track of what nodes we've jumped thorugh in order to detect cycles
but, this is not really feasible due to the way that we are copying and pasting entire subtrees when certain nodes are evaluated, so I decided to take an iterative approach instead</p>
<p>So we just walk over the DOM and flag nodes as we resolve them, and we report an error if we ever fail to make progress on a given traversal.</p>
<h2>Augmenting the parser with expression parsing</h2>
<p>This is still a work in progress, so I'll have to write more about this once It's properly complete, but to give you a sneak peak...</p>
<p>This basically has involved my ripping out the majority of the lexer and simply defering to the lead sheets parser for all but the major structural tokens
And this is really odd, because now entire expressions are essentially just treated as a type of token by the gon parser.
And because the lexer doesn't know the state of the parser, it doesn't know whether we expect only a simple string or an expression, which are the same thing to the LS parser
we <em>could</em> just hint to the gon lexer that we are expecting a simple string next rather than an expression, but the problem</p>
<p>Another tricky bit is that both the gon and LS lexers sort of run ahead by one token so that the user can peek a token without consuming it.</p>
<p>I think I will probably just end up entirely removing the lexer as a piece of state, and instead just call the lex_next_token proc directly, that way I can hint when I expect a name or a full expression</p>
<p>The tricky bit is that both of these parsers are structured in such a way that they parse</p>
<p>I have now entirely reimplemented the GON parser in terms of Lead Sheets, which has made it much simpler overall.
This has required adding some additional features to Lead Sheets that make the framework a bit more flexible.
The primary change was allowing the user to override the main lexing and parsing procedures, and to provide user callbacks for typechecking and evaluation.
The user can also quite trivially create their own node types as well.</p>
<p>I used substitute versions of parse_leaf and parse_binary to remove struct literals from the language, since the GON parser thinks a bit more lexically, in terms of objects and arrays.</p>
<p>The implementation of field references has changed one again, and this time it's just a bit of a parsing hack.
When we hit a prefix <code>$</code> or <code>&amp;</code> operator, we then look for a following string that represents a field path. This then gets packaged up as a Node_Reference for typechecking to handle.
I think I deally I would rather have a more general mechanism for handling compile-time operators, allowing operators to work similarly to directives.
But, for the mean time, this solution is the most simple and due to the operator selection, there's no conflicts with the default functionality of Lead Sheets.</p>

</div> </body> </html>